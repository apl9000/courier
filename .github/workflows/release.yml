name: Release

# Release workflow that triggers on push to main or manual dispatch
# For automatic releases: version bump is determined from commit messages
# - "BREAKING CHANGE:" or "!:" triggers major version bump
# - "feat:" triggers minor version bump
# - "fix:", "chore:", etc. triggers patch version bump
# For manual releases: explicit version bump selection required
on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      confirm:
        description: "Type 'yes' to confirm publishing this version"
        required: true
        type: string

permissions:
  contents: write
  id-token: write
  pull-requests: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    environment: copilot
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Recreate lockfile for current Deno version
        run: deno cache --reload mod.ts src/** tests/**

      - name: Determine current version
        id: current
        run: |
          current=$(deno eval "console.log(JSON.parse(Deno.readTextFileSync('deno.json')).version)")
          echo "current=${current}" >> $GITHUB_OUTPUT

      - name: Determine version bump type
        id: bump_type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - use provided input
            bump="${{ github.event.inputs.bump }}"
            echo "Using manual bump type: $bump"
          else
            # Automatic trigger - analyze commit messages
            echo "Analyzing commit messages to determine version bump..."

            # Get commit message
            commit_msg=$(git log -1 --pretty=%B)
            echo "Commit message: $commit_msg"

            # Determine bump type based on conventional commits
            # Check for breaking changes first (highest priority)
            if echo "$commit_msg" | grep -qE "BREAKING CHANGE:"; then
              bump="major"
              echo "üö® Detected BREAKING CHANGE in commit body - major version bump"
            elif echo "$commit_msg" | grep -qiE "^(feat|fix|chore|docs|style|refactor|perf|test|build|ci)(\(.+\))?!:"; then
              bump="major"
              echo "üö® Detected breaking change marker (!) - major version bump"
            elif echo "$commit_msg" | grep -qiE "^feat(\(.+\))?:"; then
              bump="minor"
              echo "‚ú® Detected feature - minor version bump"
            elif echo "$commit_msg" | grep -qiE "^(fix|chore|docs|style|refactor|perf|test|build|ci)(\(.+\))?:"; then
              bump="patch"
              echo "üîß Detected fix/chore - patch version bump"
            else
              # No conventional commit format found - fail with clear message
              echo "‚ùå ERROR: Commit message does not follow conventional commits format"
              echo "Expected format: <type>[optional scope]: <description>"
              echo "Valid types: feat, fix, chore, docs, style, refactor, perf, test, build, ci"
              echo "For breaking changes: add '!' after type or include 'BREAKING CHANGE:' in body"
              echo ""
              echo "Commit message was:"
              echo "$commit_msg"
              exit 1
            fi
          fi

          echo "bump=${bump}" >> $GITHUB_OUTPUT
          echo "**Version Bump Type:** \`${bump}\`" >> $GITHUB_STEP_SUMMARY

      - name: Calculate next version
        id: next
        run: |
          bump="${{ steps.bump_type.outputs.bump }}"
          current="${{ steps.current.outputs.current }}"
          cat <<'EOF' > /tmp/bump.ts
          const [current, bump] = Deno.args;
          const parts = current.split('.').map((n) => parseInt(n, 10));
          if (parts.length !== 3 || parts.some((n) => Number.isNaN(n))) {
            console.error('Invalid current version', current);
            Deno.exit(1);
          }
          const [maj, min, patch] = parts;
          let next = [maj, min, patch];
          if (bump === 'major') next = [maj + 1, 0, 0];
          else if (bump === 'minor') next = [maj, min + 1, 0];
          else next = [maj, min, patch + 1];
          console.log(next.join('.'));
          EOF
          next=$(deno run /tmp/bump.ts "$current" "$bump")
          echo "bump=${bump}" >> $GITHUB_OUTPUT
          echo "next=${next}" >> $GITHUB_OUTPUT
          echo "**Proposed Version:** \`$current\` ‚Üí \`$next\` (\`${bump}\` bump)" >> $GITHUB_STEP_SUMMARY

      - name: Confirmation gate
        if: github.event_name == 'workflow_dispatch'
        run: |
          confirm="${{ github.event.inputs.confirm }}"
          if [ "$confirm" != "yes" ]; then
            echo "‚ùå Confirmation required to proceed with release" >> $GITHUB_STEP_SUMMARY
            echo "Rerun the workflow with confirm: 'yes' to publish version ${{ steps.next.outputs.next }}" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          echo "‚úÖ Release confirmed for version ${{ steps.next.outputs.next }}" >> $GITHUB_STEP_SUMMARY

      - name: Run quality checks
        run: |
          deno task fmt:check
          deno lint
          deno task check

      - name: Generate snapshots
        run: deno task snapshots

      - name: Validate snapshots
        run: deno task test:snapshots

      - name: Run unit tests with coverage
        run: deno test --allow-read --allow-env --coverage=coverage_profile src/**/*.spec.ts

      - name: Run integration tests with coverage
        env:
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TEST_TO: ${{ secrets.SMTP_TEST_TO }}
        run: deno test --allow-net --allow-read --allow-env --coverage=coverage_profile tests/**/*.integration.spec.ts

      - name: Generate coverage report
        run: deno coverage coverage_profile --lcov --output=coverage.lcov

      - name: Check coverage threshold (90%)
        run: |
          # Generate detailed coverage report
          deno coverage coverage_profile --detailed > coverage_report.txt
          cat coverage_report.txt

          # Extract overall coverage percentage
          coverage=$(deno coverage coverage_profile | grep -oP 'cover \K[0-9.]+(?=%)' | head -1)
          echo "Code coverage: ${coverage}%"
          echo "## üìä Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "Coverage: **${coverage}%**" >> $GITHUB_STEP_SUMMARY

          # Check if coverage meets 90% threshold
          if (( $(echo "$coverage < 90" | bc -l) )); then
            echo "‚ùå Coverage ${coverage}% is below the required 90% threshold" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "‚úÖ Coverage meets the 90% threshold" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update version in deno.json
        run: |
          next="${{ steps.next.outputs.next }}"
          deno eval "const obj=JSON.parse(Deno.readTextFileSync('deno.json')); obj.version='${next}'; Deno.writeTextFileSync('deno.json', JSON.stringify(obj, null, 2)+'\\n');"
          echo "Updated deno.json version to ${next}" >> $GITHUB_STEP_SUMMARY

      - name: Commit version bump and built assets
        id: commit
        run: |
          next="${{ steps.next.outputs.next }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add deno.json
          if git status --porcelain | grep .; then
            git commit -m "chore: release v${next}"
            git tag "v${next}"
            git push origin HEAD:main
            git push origin "v${next}"
            echo "tag=v${next}" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.commit.outputs.tag }}',
            });
            return data.body;
          result-encoding: string

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.commit.outputs.tag }}" \
            --title "Release ${{ steps.commit.outputs.tag }}" \
            --notes "${{ steps.release_notes.outputs.result }}"

      - name: Publish to JSR
        run: npx jsr@latest publish
