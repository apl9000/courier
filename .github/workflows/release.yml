name: Release

# This workflow must be manually triggered to create a release.
# It will not run automatically on pushes to prevent accidental releases.
on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type (patch|minor|major)"
        required: false
        default: "patch"
      confirm:
        description: "Type 'yes' to confirm publishing this version"
        required: false
        default: "no"

permissions:
  contents: write
  id-token: write
  pull-requests: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    environment: copilot
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Recreate lockfile for current Deno version
        run: deno cache --reload mod.ts src/** tests/**

      - name: Determine current version
        id: current
        run: |
          current=$(deno eval "console.log(JSON.parse(Deno.readTextFileSync('deno.json')).version)")
          echo "current=${current}" >> $GITHUB_OUTPUT

      - name: Suggest next version
        id: next
        run: |
          bump="${{ github.event.inputs.bump || 'patch' }}"
          current="${{ steps.current.outputs.current }}"
          cat <<'EOF' > /tmp/bump.ts
          const [current, bump] = Deno.args;
          const parts = current.split('.').map((n) => parseInt(n, 10));
          if (parts.length !== 3 || parts.some((n) => Number.isNaN(n))) {
            console.error('Invalid current version', current);
            Deno.exit(1);
          }
          const [maj, min, patch] = parts;
          let next = [maj, min, patch];
          if (bump === 'major') next = [maj + 1, 0, 0];
          else if (bump === 'minor') next = [maj, min + 1, 0];
          else next = [maj, min, patch + 1];
          console.log(next.join('.'));
          EOF
          next=$(deno run /tmp/bump.ts "$current" "$bump")
          echo "bump=${bump}" >> $GITHUB_OUTPUT
          echo "next=${next}" >> $GITHUB_OUTPUT
          echo "Proposed bump: $bump (current $current -> next $next)" >> $GITHUB_STEP_SUMMARY

      - name: Confirmation gate
        run: |
          confirm="${{ github.event.inputs.confirm || 'no' }}"
          if [ "$confirm" != "yes" ]; then
            echo "Confirmation required. Rerun the workflow with confirm: yes and (optionally) bump: patch|minor|major." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Run quality checks
        run: |
          deno task fmt:check
          deno lint
          deno task check

      - name: Generate snapshots
        run: deno task snapshots

      - name: Validate snapshots
        run: deno task test:snapshots

      - name: Run unit tests with coverage
        run: deno test --allow-read --allow-env --coverage=coverage_profile src/**/*.spec.ts

      - name: Run integration tests with coverage
        env:
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM: ${{ secrets.SMTP_FROM }}
          SMTP_TEST_TO: ${{ secrets.SMTP_TEST_TO }}
        run: deno test --allow-net --allow-read --allow-env --coverage=coverage_profile tests/**/*.integration.spec.ts

      - name: Generate coverage report
        run: deno coverage coverage_profile --lcov --output=coverage.lcov

      - name: Check coverage threshold (90%)
        run: |
          # Generate detailed coverage report
          deno coverage coverage_profile --detailed > coverage_report.txt
          cat coverage_report.txt

          # Extract overall coverage percentage
          coverage=$(deno coverage coverage_profile | grep -oP 'cover \K[0-9.]+(?=%)' | head -1)
          echo "Code coverage: ${coverage}%"
          echo "## ðŸ“Š Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "Coverage: **${coverage}%**" >> $GITHUB_STEP_SUMMARY

          # Check if coverage meets 90% threshold
          if (( $(echo "$coverage < 90" | bc -l) )); then
            echo "âŒ Coverage ${coverage}% is below the required 90% threshold" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "âœ… Coverage meets the 90% threshold" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update version in deno.json
        run: |
          next="${{ steps.next.outputs.next }}"
          deno eval "const obj=JSON.parse(Deno.readTextFileSync('deno.json')); obj.version='${next}'; Deno.writeTextFileSync('deno.json', JSON.stringify(obj, null, 2)+'\\n');"
          echo "Updated deno.json version to ${next}" >> $GITHUB_STEP_SUMMARY

      - name: Commit version bump and built assets
        id: commit
        run: |
          next="${{ steps.next.outputs.next }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add deno.json
          if git status --porcelain | grep .; then
            git commit -m "chore: release v${next}"
            git tag "v${next}"
            git push origin HEAD:main
            git push origin "v${next}"
            echo "tag=v${next}" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.commit.outputs.tag }}',
            });
            return data.body;
          result-encoding: string

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.commit.outputs.tag }}
          release_name: Release ${{ steps.commit.outputs.tag }}
          body: ${{ steps.release_notes.outputs.result }}
          draft: false
          prerelease: false

      - name: Publish to JSR
        run: npx jsr@latest publish
